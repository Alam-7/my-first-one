<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>
    <script>
      //块作用域（var,let,const的区别）
      //var声明的变量没有块作用域  容易混淆
      //let,const都有块作用域  因此一般使用let而不是用var

      //栈与堆
      //1.栈：操作系统自动分配的变量存放在栈内  由操作系统自动管理 例如函数的形参，局部变量等基本数据类型
      //2.堆：由人自主管理，如果不自己释放则有垃圾回收机制回收  一般存放复杂数据类型  例如对象，数组

      //回收机制：
      //1.引用计数：检查该数据是否有可以找到或者指向的对象 例如数组建立并使用后将数组设为null，内存丢失  无法指向后释放该数据
      //但是无法处理相互循环引用的数据
      //2.标记引用：从表层来去进行检索 定期寻找目前能找到的数据，然后将用查找链找不到的数据清除掉 因为“用不到”了
      //这样子就可以清除掉那些相互引用 但从表层无法使用掉的数据
      //目前一般都使用标记引用算法

      //闭包=内层函数+外层变量(环境)
      //每一个函数或者方法在建立的时候如果有周围的环境就会自带一个闭包，内部包含了一系列的环境数据，因此当离开了原有的变量环境后仍然可以通过闭包来得到这些数据
      //重要应用:1.实现变量数据的私有化 外部仅仅通过自己设定的方法来对这个私有数据或者函数进行操作，而不能直接调用更改
      //2.

      //变量提升：当块作用域执行时会首先检索所有的var声明 并且将其提升至最上方 但是只会提升声明位置 不提升所赋予的值

      //函数提升 与变量提升类似会首先将函数声明提升  但注意函数表达式声明var也是赋值 不会提升赋值

      //考虑一个问题：需要写一个函数可以接受任意个参数并对它们进行操作
      //由于参数会提前确定数量 因而难以确定形参
      //arguments动态参数 是一个伪数组 只在函数内出现 能够接受传入的参数
      //   function add() {
      //     let sum = 0;
      //     for (let i = 0; i < arguments.length; i++) {
      //       sum += arguments[i]; //数组内存储传入的所有参数
      //     }
      //     console.log(sum);
      //   }
      //   add(1, 2);
      //   add(1, 3);

      //剩余参数：创建一个数组 内部存储函数所传进的参数的所有剩余参数
      //   function left(a, b, ...arr) {
      //     console.log(arr);
      //   }
      //   left(1, 2);
      //   left(1, 2, 3, 4, 5);
      //另外需要注意一点剩余参数一个真数组具有原型以及附带的一系列方法
      //并且箭头函数无法使用arguments动态参数 因而一般常用剩余参数

      //... 也叫做展开运算符 可以展开一个数组的所有元素 即...arr===a,b,c,d
      //一般常用于两个用途：求最大值，合并数组  求最大值可以直接...丢到math.max中得到最大值 而两个...arr1,...arr2可以将两个数组元素放在一起

      //箭头函数 ()=>{}等于匿名函数
      //   let x = 1;
      //   //1.只有一个参数的时候可以省略小括号
      //   const fn1 = (x) => {
      //     console.log(x);
      //   };
      //   //2.只有一行执行代码时可以省略大括号
      //   const fn2 = (x) => console.log(x);
      //   fn1(x);
      //   fn2(x);

      // const fn = (uname) => ({ name: uname }); //这里的大括号表示对象的创建 加上小括号防止与函数的大括号混淆
      // console.log(fn("123"));

      //箭头函数没有动态参数arguments  但是有剩余参数 并且一般也都用剩余参数
      // const sum = (...arr) => {
      //   let sum = 0;
      //   for (let i = 0; i < arr.length; i++) {
      //     sum += arr[i];
      //   }
      //   console.log(sum);
      // };

      // sum(1, 2, 3, 4, 5, 6, 7, 8, 9);

      //箭头函数的this
      //谁调用函数   This指向谁  window.fun();
      //箭头函数不会创建自己的this只会去沿用自己上一层作用域中的this  例如 一个普通函数包着一个箭头函数 箭头函数就沿用这个普通函数的this  一直到最外层的window
      //在事件回调脚本函数中的this一般都指向window所以不要用箭头函数或者不用this

      //结构赋值：
      //1.数组解构：将数组中的变量一一赋值给一系列的变量 （让其中的元素有可辨识性和可用）
      // const arr = [100, 200, 300];
      // const [min, mid, max] = arr; //与右边数组中的元素一一对应
      // console.log(max);  //注意这里的变量是新创建的变量只是拷贝了原来的值 数组结构相当于遍历数组元素并赋值创建新变量

      //典型应用：交换变量
      // let a = 1;
      // let b = 2;//注意这里的分号必须加  但是prirrer已经自动添加了
      // [b, a] = [a, b]; //这里的两个a和b还是原来的a,b吗  如果不是的话相当于重新声明但应当报重名错误 因而还是原来的？
      // console.log(a, b);

      //两种必须加分号的情况:1.立即执行函数 2.数组开头（数组会自动向前缩进导致与上一语句相连）

      // function getValue() {
      //   return [100, 60];
      // }
      // const [max, min] = getValue();
      // console.log(max, min);

      //另外根据单元值和变量之间的的数量关系 可以适当采用剩余参数来处理单元值多的情况 可以采用参数默认值来防止undefined行为

      // const [a, b, ...arr] = [1, 2, 3, 4, 5, 6, 7, 8, 9];
      // arr.map((ele) => {
      //   console.log(ele);
      // });

      //当然也可以多维数组结构 只需要对应位置设置变量即可

      //2.对象结构：2.1将右侧的对象属性一一赋值给左侧的变量（类似于数组结构，需要有相同的格式）
      //2.2要求新赋值的变量名要与属性名完全一致！！！否则未定义
      //2.3不要与外部变量冲突
      // const { uname1, age } = { uname: "123", age: 18 };
      // console.log(uname1);

      //一定需要改名的话怎么办？  原来的：新的
      // const { uname: uname1, age } = { uname: "123", age: 18 }; //冒号修改变量名
      // console.log(uname1);

      //数组对象解构：将以上两种结构混合即可 解构实质上只是一种较为简洁的语法 要求新的变量赋值格式和原来的格式一一对应相同即可

      // const pig = { name: "佩奇", age: 6 };
      // const { name: pigname, age } = pig;
      // console.log(pigname, age);
      // const [{ goodsName, price }] = [{ goodsName: "小米", price: 1999 }];
      //这里的两个变量与原对象无关 只是以原来的格式新创建的变量 更加便于使用
      //无论是多么复杂的对象结构只要根据它原来的语法一一模仿 在对应位置替换为变量名即可
      //另外注意复杂对象解构时变量会去自动索引所对应的数据  因而也没有必要非一一对应（位置上）

      //开发应用：
      // const msg = { message: "success", data: [1, 2] };
      // function render({ data }) {//注意这个data变量相当于处于函数内部 的一个解构变量
      //   console.log(data);
      // }
      // render(msg); //传入msg的同时进行解构抽出其中的data有效数据

      //foreach遍历数组
      ///map遍历并返回数组 而foreach仅仅遍历不返回
      //其他的语法基本相同 括号内部嵌套函数体

      // const arr = [1, 2, 3];
      // arr.forEach((item, index) => {
      //   console.log(item, index);
      // });
      //便于遍历数组对象

      //filter筛选数组

      // const arr = [10, 20, 30]; //返回一个新数组
      // const result=arr.filter((item,index)=>{
      //   return item>=20;//筛选要求
      // })
      //简化版
      // const result = arr.filter((item) => item >= 20);
      // console.log(result);
    </script>
  </body>
</html>
