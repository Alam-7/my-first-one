<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>面向对象封装消息提示</title>
    <style>
      .modal {
        width: 300px;
        min-height: 100px;
        box-shadow: 0 0 10px rgba(0, 0, 0, 0.2);
        border-radius: 4px;
        position: fixed;
        z-index: 999;
        left: 50%;
        top: 50%;
        transform: translate3d(-50%, -50%, 0);
        background-color: #fff;
      }

      .modal .header {
        line-height: 40px;
        padding: 0 10px;
        position: relative;
        font-size: 20px;
      }

      .modal .header i {
        font-style: normal;
        color: #999;
        position: absolute;
        right: 15px;
        top: -2px;
        cursor: pointer;
      }

      .modal .body {
        text-align: center;
        padding: 10px;
      }

      .modal .footer {
        display: flex;
        justify-content: flex-end;
        padding: 10px;
      }

      .modal .footer a {
        padding: 3px 8px;
        background: #ccc;
        text-decoration: none;
        color: #fff;
        border-radius: 2px;
        margin-right: 10px;
        font-size: 14px;
      }

      .modal .footer a.submit {
        background-color: #369;
      }
    </style>
  </head>

  <body>
    <button id="delete">删除</button>
    <button id="login">登录</button>

    <!-- <div class="modal">
    <div class="header">温馨提示 <i>x</i></div>
    <div class="body">您没有删除权限操作</div>
  </div> -->

    <script>
       //核心功能：利用面向对象编程 当发生点击事件时创建相同形式的modal盒子，并且具有相同的方法，主要考察对象的封装，可复用性，this的指向
      //1.创建modal盒子 利用构造函数 也就是首先建立一个工厂
      const Modal = function (title = "", message = "") {
        //公共属性
        this.title = title;
        this.message = message;

        //为什么要用this 他的指向在这里是谁？构造函数和他的原型中的this都指向实例化后的调用者即实例化对象
        //1.1创建节点
        this.modalBox = document.createElement("div");
        //1.2添加css
        this.modalBox.className = "modal";
        //1.3添加内容
        this.modalBox.innerHTML = `<div class="modal">
    <div class="header">$${title} <i>x</i></div>
    <div class="body">${message}</div>
  </div> `;
      };

      //1.4 Open      为工厂的模板添加方法属性 因为之后的点击和删除都是共享的
      Modal.prototype.open = function () {
        //1.4.1提前检验 如果已经有了就删除这个节点  避免多次叠加
        const box = document.querySelector(".modal");
        box && box.remove();
        //1.4.2直接添加到文档页面 this指向调用open的子对象
        document.body.appendChild(this.modalBox);

        //1.4.3绑定close事件
        this.modalBox.querySelector("i").addEventListener("click", () => {
          //要求点击后删除这个节点 this应当指向实例化对象 因而可以使用箭头函数使其到上一级作用域查找
          // console.log(this);//指向modal实例化对象
          this.close();
        });
      };

      //因为后续的close事件要求必须出现open 所以在Open的同时就可以绑定close事件 而且不影响 因为只有open了才能close
      //1.5 Close
      Modal.prototype.close = function () {
        document.body.removeChild(this.modalBox);
      };

      //至此工厂已经建立完成 只要在触发事件的时候调用工厂生产产品即可
      //
      //
      //
      //2.事件绑定 生产产品
      const del = document.querySelector("#delete");
      del.addEventListener("click", () => {
        //创建孩子并添加到web中
        const delmodal = new Modal("温馨提示", "您没有删除权限操作");
        delmodal.open(); //这个时候也同时绑定了close事件后续点击后自动生效
      });

      const login = document.querySelector("#login");
      login.addEventListener("click", () => {
        const logmodal = new Modal("再次提示", "您还没有注册！");
        logmodal.open();
      });
      //
      //
      //
      //
      //
      //
      //
      //
      //
      // // 1.  模态框的构造函数
      //     function Modal(title = '', message = '') {
      //       // 公共的属性部分
      //       this.title = title
      //       this.message = message
      //       // 因为盒子是公共的
      //       // 1. 创建 一定不要忘了加 this
      //       this.modalBox = document.createElement('div')
      //       // 2. 添加类名
      //       this.modalBox.className = 'modal'
      //       // 3. 填充内容 更换数据
      //       this.modalBox.innerHTML = `
      //         <div class="header">${this.title} <i>x</i></div>
      //         <div class="body">${this.message}</div>
      //       `
      //       // console.log(this.modalBox)
      //     }
      //     // 2. 打开方法 挂载 到 模态框的构造函数原型身上
      //     Modal.prototype.open = function () {
      //       if (!document.querySelector('.modal')) {
      //         // 把刚才创建的盒子 modalBox  渲染到 页面中  父元素.appendChild(子元素)
      //         document.body.appendChild(this.modalBox)
      //         // 获取 x  调用关闭方法
      //         this.modalBox.querySelector('i').addEventListener('click', () => {
      //           // 箭头函数没有this 上一级作用域的this
      //           // 这个this 指向 m
      //           this.close()
      //         })
      //       }
      //     }
      //     // 3. 关闭方法 挂载 到 模态框的构造函数原型身上
      //     Modal.prototype.close = function () {
      //       document.body.removeChild(this.modalBox)
      //     }

      //     // 4. 按钮点击
      //     document.querySelector('#delete').addEventListener('click', () => {
      //       const m = new Modal('温馨提示', '您没有权限删除')
      //       // 调用 打开方法
      //       m.open()
      //     })

      //     // 5. 按钮点击
      //     document.querySelector('#login').addEventListener('click', () => {
      //       const m = new Modal('友情提示', '您还么有注册账号')
      //       // 调用 打开方法
      //       m.open()
      //     })
    </script>
  </body>
</html>

