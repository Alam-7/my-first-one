<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
    <style>
      button {
        /* width: 50px; */
        height: 50px;
        background-color: pink;
        align-items: center;
        line-height: 50px;
        border-radius: 50%;
      }
    </style>
  </head>
  <body>
    <button>点击后禁用两秒</button>

    <script>
      //注意对象名是在栈区存放的地址名 所以直接对象赋值会导致修改对象数据本身
      //浅拷贝与深拷贝：
      //直接赋值会将原对象整体的地址赋值给新对象
      //而浅拷贝会将对象的内容拷贝给新对象 不是仅仅拷贝对象（assign方法）  但是如果内部嵌套的还有对象 则其本身在母对象中存储的还是地址 不会将子对象展开拷贝
      //导致子对象仍然会影响
      // const person1 = {
      //   name: "123",
      //   age: 18,
      //   child: {
      //     name: "124",
      //     age: 12,
      //   },
      // };
      // const person2 = {};
      // // Object.assign(person2, person1);

      // //那么怎么实现深度拷贝呢？ 实现数据的完全拷贝  遍历对象中的每一个值逐个拷贝？似乎没有别的办法了？最多也是简化
      // //设置一个深拷贝函数 逐个遍历拷贝 但是简单的一层拷贝也会导致浅拷贝
      // //那么不妨首先实现浅拷贝再对深层加以考虑
      // function deepCopy(newObj, oldObj) {
      //   for (let k in oldObj) {
      //     if (oldObj[k] instanceof Array) {
      //       newObj[k] = []; ///为什么需要提前初始化？  因为数组，对象等复杂数据类型并不会自动创建 也就是在赋值时会发生undefined错误
      //       //现在的K 是对象中的数组 因而仍然需要逐个访问并（深层）拷贝，并且发现如果有对象这将是一个无穷递归问题 所以调用递归
      //       deepCopy(newObj[k], oldObj[k]);
      //     } else if (oldObj[k] instanceof Object) {
      //       //初始化
      //       newObj[k] = {};
      //       //深度拷贝递归
      //       deepCopy(newObj[k], oldObj[k]);
      //     } else {
      //       //将旧对象中的元素k  拷贝到New对象中
      //       newObj[k] = oldObj[k]; //[]本身带有访问性质 在Js中如果没有这个属性或者方法就自动创建 但是注意如果是数组等复杂数据类型则不会自动创建（undefined)
      //       //但仍然是浅拷贝 如果有复杂数据类型则只拷贝了它们的地址
      //       //那么就可以加以分类判断 是否是复杂类型
      //     }
      //   }
      // }

      // //下面再来实验一下
      // deepCopy(person2, person1);
      // person2.child.name = "张三";
      // console.log(person1);
      // //OK
      //实质上是对地址的逐层访问  赋值——最外层地址 浅拷贝——单层地址 深拷贝——递归实现地址逐层拆解
      //另外可以采用lodash库中的工具函数

      //另外如果是从后台接受数据  由于传过来的时候就已经是整个对象的完整JSON字符串 已经经过了“地址”的访问
      //因而直接拷贝这个JSON字符串即可 自动会重新建立一个地址区

      // const person1 = {
      //   name: "123",
      //   age: 18,
      //   child: {
      //     name: "124",
      //     age: 12,
      //   },
      // };
      // const person2 = JSON.parse(JSON.stringify(person1)); //模拟了后台数据 当然也可以直接采用这种方式深度拷贝
      // person2.child.name = "张三";
      // console.log(person1);
      // console.log(person2);

      //抛出错误处理：编程过程中经常能遇到一些自己不太确定能否执行的代码 并且如果不能执行就会导致程序中断 那么现在非常难受于怎么检验代码是否有误   并且我还需要后面的一部分代码继续执行
      //那么try...catch...throw..   finally
      //首先写一段程序
      // const obj = {
      //   name: "123",
      // };
      // //要注意try catch是一个独立作用域块 所以尽量不要在里面声明变量 也就是说try catch仅适用于较短的几行代码检查错误
      // try {
      //   obj2.name = "张三"; //有错误 但是不暂停
      // } catch (err) {
      //   console.log(err.message); //打印出来了
      //   //如果仅有try catch则不会终止程序运行 如果需要终止则需要throw
      //   throw new Error("出错误了 下面的程序暂停");
      //   //....一些要暂停的代码
      // } finally {
      //   console.log(obj); //必须执行的代码
      // }

      //this指向问题

      //this到底指向谁
      //1.普通函数：谁调用函数  this指向谁
      // console.log(this); //window调用
      //另外如果js开启了严格模式“use strict”则没有调用者时 默认undefined而不是window(原本默认window)
      //严格模式暂不清楚
      //2.箭头函数:实质上箭头函数没有this  而是根据作用域链寻找最近的外层this
      //注意：1.如果有DOM事件就尽量不要使用箭头函数（或者看情况注意）  2.构造函数和原型中绑定的方法都是需要实例对象来调用的 有明确的this指向 因此最好不要使用箭头函数
      //另外如果有些地方确实需要沿用上一层this的时候就可以是用箭头函数  最关键的就是要时刻明确自己到底需要this指向谁

      //This指向的更改 call apply bind方法
      //call
      // const obj = {
      //   name: "123",
      // };
      // function fn(x = 0, y = 0) {
      //   console.log(this);

      //   console.log(x + y);
      // }
      // fn.call(obj, 1, 2); //增加一个参数是调用的函数内部时的this指向  但是call方法不常用

      //apply 与call不同的是 apply需要将参数包装为数组 以数组的形式再分配到函数中 因而常用于数组求最大值
      // const arr = [1, 2, 5, 8];
      // const max = Math.max.apply(Math, arr); //第一个参数仍然是this指向 但是没什么用 第二个参数是一个数组将被拆开传进Max函数
      // console.log(max);
      // console.log(Math.max(...arr));

      //bind 不会调用函数 但是可以直接更改this指向
      //函数调用bind直接更改This指向 然后返回新的更改过指向的新函数拷贝 当然也可以在This指向后添加想要添加的初始化参数
      // const obj = {
      //   name: "张三",
      // };
      // function fn() {
      //   console.log(this);
      // }
      // const newFn = fn.bind(obj);
      // fn();
      // newFn();//便于之后延时调用

      //this指向更改常在定时器中使用 因为定时器往往是window调用 如果想使用this就需要修改
      //例：设置一个定时器按钮 点击后禁用两秒
      // const btn = document.querySelector("button");
      // btn.addEventListener("click", function () {
      //   this.disabled = true;
      //   setTimeout(
      //     function () {
      //       this.disabled = false;
      //     }.bind(this), //这里的this就是外层的   因为定时器默认是window调用 所以一般需要直接修改this指向
      //     2000
      //   );
      // });

      //防抖：当一个事件可能会被频繁触发但是并不需要执行这么多次 而只需要执行最后的有效次（以事件次数为依据 做了这么多次事件 但我看作是一次）
      //实现：不断清除并设置定时器 来实现事件的演示判断  lodash库中有

      //节流：仍然是频繁触发的事件  每一段时间内最多执行一次某个事件（以时间为依据 这么长时间之内我都看作是一次  减少消耗）
      //实现：
      // let timer = null;
      // timer = setTimeout(() => {
      //   // clearTimeout(timer);
      //   timer = null;
      //   console.log(timer);
      // }, 1000);
    </script>
  </body>
</html>
